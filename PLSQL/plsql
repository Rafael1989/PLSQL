#CRIAR USUÁRIO
CREATE USER cursoplsql IDENTIFIED BY cursoplsql
                       DEFAULT tablespace users;
                       
#DAR PERMISSÃO PARA O USUÁRIO
GRANT connect, resource TO cursoplsql;

#CRIAR TABELA
CREATE TABLE SegMercado(ID NUMBER(5),Descricao VARCHAR2(100));
CREATE TABLE Cliente
  ( ID NUMBER(5),
    Razao_Social VARCHAR2(100),
    CNPJ VARCHAR2(20),
    SegMercado_id NUMBER(5),
    Data_Inclusao DATE,
    #8 INTEIRO E 2 DECIMAIS
    Faturamento_Previsto NUMBER(10,2),
    Categoria VARCHAR2(20));

#NÃO DEIXAR ID NULO OU REPETIDO
ALTER TABLE Segmercado ADD CONSTRAINT SegMercado_id_pk PRIMARY KEY(ID);
ALTER TABLE Cliente ADD CONSTRAINT Cliente_id_pk PRIMARY KEY(ID);

#ADICIONA CHAVE ESTRANGEIRA
ALTER TABLE Cliente ADD CONSTRAINT Cliente_SegMercado_fk FOREIGN KEY(SegMercado_id) REFERENCES Segmercado(id) ;

#BLOCO PL/SQL

#LIGA VARIAVEL
SET SERVEROUTPUT ON

#DECLARAR VARIAVEIS
DECLARE
    v_id number(5) := 1;

#INÍCIO DO BLOCO
BEGIN
    v_id := 2;
    
    #IMPRIME NO CONSOLE
    Dbms_output.put_line(v_id);

#FIM DO BLOCO
END;

#BLOCO INSERT PL/SQL
DECLARE
    v_id number(5) := 1;
    v_descricao varchar2(100) := 'varejo';

BEGIN

    INSERT INTO segmercado VALUES (v_id, v_descricao);
    COMMIT;

END;

#BLOC PL/SQL SEM TIPOS(BOA PRÁTICA) + UPPERCASE
DECLARE
    v_id segmercado.id%type := 3;
    v_descricao segmercado.descricao%type := 'atacado';
BEGIN
    INSERT INTO SEGMERCADO VALUES (v_id,upper(v_descricao));
    COMMIT;
END;

#UPDATE
DECLARE
    v_id segmercado.id%type := 1;
    v_descricao segmercado.descricao%type := 'varejista';
BEGIN
    UPDATE SEGMERCADO SET DESCRICAO = UPPER(v_descricao) WHERE id = v_id;
    
    v_id := 2;
    v_descricao := 'atacadista';
    
    UPDATE SEGMERCADO SET DESCRICAO = UPPER(v_descricao) WHERE id = v_id;
    COMMIT;
END;

#DELETE
DECLARE
    v_id segmercado.id%type := 3;
BEGIN
    DELETE FROM SEGMERCADO WHERE id = v_id;
    COMMIT;
END;


#CRIAR PROCEDURE
CREATE PROCEDURE incluir_segmercado(p_id IN NUMBER, p_descricao IN VARCHAR2)
IS
BEGIN
    INSERT INTO SEGMERCADO VALUES(p_id,UPPER(p_descricao));
    COMMIT;
END;


#CRIAR FUNCTION
CREATE OR REPLACE FUNCTION obter_descricao_segmercado (p_id IN segmercado.id%type)
RETURN segmercado.descricao%type

IS
    v_descricao segmercado.descricao%type;

BEGIN
    SELECT descricao INTO v_descricao
        FROM segmercado
        WHERE id = p_id;
    RETURN v_descricao;
END;

#PROCEDURE COM IF
CREATE OR REPLACE PROCEDURE INCLUIR_CLIENTE 
   (p_id in cliente.id%type,
    p_razao_social IN cliente.razao_social%type,
    p_CNPJ cliente.CNPJ%type ,
    p_segmercado_id IN cliente.segmercado_id%type,
    p_faturamento_previsto IN cliente.faturamento_previsto%type)
IS
    v_categoria cliente.categoria%type;

BEGIN

    IF p_faturamento_previsto < 10000 THEN
       v_categoria := 'PEQUENO';
        ELSIF p_faturamento_previsto < 50000 THEN
        v_categoria := 'MEDIO';
        ELSIF p_faturamento_previsto < 100000 THEN
        v_categoria := 'MEDIO GRANDE';
        ELSE
        v_categoria := 'GRANDE';
        END IF;

    INSERT INTO cliente VALUES (p_id, UPPER(p_razao_social), p_CNPJ,p_segmercado_id, SYSDATE, p_faturamento_previsto, v_categoria);
    COMMIT;

END;

#CRIAR FUNCTION
CREATE OR REPLACE FUNCTION categoria_cliente (p_faturamento_previsto IN cliente.faturamento_previsto%type) RETURN cliente.categoria%type

IS
BEGIN

    IF p_faturamento_previsto < 10000 THEN
           RETURN 'PEQUENO';
        ELSIF p_faturamento_previsto < 50000 THEN
            RETURN 'MEDIO';
        ELSIF p_faturamento_previsto < 100000 THEN
            RETURN 'MEDIO GRANDE';
        ELSE
            RETURN 'GRANDE';
        END IF;
END;

#PROCEDURE PARA FORMATAR CNPJ
CREATE OR REPLACE PROCEDURE FORMAT_CNPJ
    (p_cnpj IN OUT cliente.CNPJ%type)

IS
BEGIN
    p_cnpj := substr(p_cnpj,1,2) || '/' || substr(p_cnpj,3);
END;

#DECLARANDO, SETANDO E EXIBINDO VARIAVEL
VARIABLE g_cnpj varchar2(10)
EXECUTE :g_cnpj := '12345'
PRINT g_cnpj

EXECUTE FORMAT_CNPJ(:g_cnpj)
PRINT g_cnpj


#FORMATANDO CNPJ NA PROCEDURE DE INCLUIR CLIENTE
CREATE OR REPLACE PROCEDURE INCLUIR_CLIENTE 
   (p_id in cliente.id%type,
    p_razao_social IN cliente.razao_social%type,
    p_CNPJ cliente.CNPJ%type ,
    p_segmercado_id IN cliente.segmercado_id%type,
    p_faturamento_previsto IN cliente.faturamento_previsto%type)
IS
    v_categoria cliente.categoria%type;
    v_CNPJ cliente.cnpj%type := p_CNPJ;

BEGIN

    v_categoria := categoria_cliente(p_faturamento_previsto);

    format_cnpj(v_cnpj);

    INSERT INTO cliente VALUES (p_id, UPPER(p_razao_social), v_CNPJ ,p_segmercado_id, SYSDATE, p_faturamento_previsto, v_categoria);
    COMMIT;

END;

#PROCEDURE UPDATE
CREATE OR REPLACE PROCEDURE ATUALIZAR_CLI_SEG_MERCADO
    (p_id IN cliente.id%type,
     p_segmercado_id IN cliente.segmercado_id%type)
    IS
BEGIN
    UPDATE cliente
        SET segmercado_id = p_segmercado_id
        WHERE id = p_id;
    COMMIT;
END;

#EXECUTANDO A PROCEDURE
DECLARE
    v_segmercado_id cliente.segmercado_id%type := 1;
    v_i number(3);
BEGIN
    v_i := 1;
LOOP
    ATUALIZAR_CLI_SEG_MERCADO(v_i, v_segmercado_id);
    v_i := v_i +1;
    EXIT WHEN v_i > 3;
 END LOOP;
END;

#USANDO O FOR LOOP
DECLARE
    v_segmercado_id cliente.segmercado_id%type := 2;
BEGIN
    FOR i in 1..3 LOOP
        ATUALIZAR_CLI_SEG_MERCADO(i, v_segmercado_id);
    END LOOP;
     COMMIT;
END;

#USANDO CURSOR
DECLARE
    v_segmercado_id cliente.segmercado_id%type := 3;
    v_id cliente.id%type;
    CURSOR cur_cliente is SELECT id from cliente; 
BEGIN
    OPEN cur_cliente;
    LOOP
       FETCH cur_cliente into v_id;
       EXIT WHEN cur_cliente%NOTFOUND;
       ATUALIZAR_CLI_SEG_MERCADO(v_id, v_segmercado_id);
    END LOOP;
END;

#CURSOR FOR LOOP
DECLARE
    v_segmercado_id cliente.segmercado_id%type := 2;
    v_id cliente.id%type;
    CURSOR cur_cliente is SELECT id from cliente; 
BEGIN
    FOR cli_rec IN cur_cliente LOOP
       ATUALIZAR_CLI_SEG_MERCADO(cli_rec.id, v_segmercado_id);
    END LOOP;
END;

#CHAMANDO PROCEDURE DE FORMA NOMEADA
DECLARE 
    v_id NUMBER;
    v_segmercado_id NUMBER;
BEGIN
    v_id := 1;
    v_segmercado_id := 3;
    atualizar_cli_seg_mercado(p_id => v_id, p_segmercado_id => v_segmercado_id);
END;

#LOOP + CURSOR
DECLARE
    v_id cliente.id%type;
    v_segmercado_id cliente.segmercado_id%type := 1;
    CURSOR cur_cliente is SELECT id FROM cliente;

BEGIN
    OPEN cur_cliente;

    LOOP
        FETCH cur_cliente into v_id;
        EXIT WHEN cur_cliente%NOTFOUND;
        ATUALIZAR_CLI_SEG_MERCADO(v_id, v_segmercado_id);
    END LOOP;

    CLOSE cur_cliente;

    COMMIT;

END;

#LOOP + CURSOR MAIS SUCINTO
DECLARE
    v_segmercado_id cliente.segmercado_id%type := 2;
    CURSOR cur_cliente is SELECT id FROM cliente;

BEGIN

    FOR cli_rec IN cur_cliente LOOP
        ATUALIZAR_CLI_SEG_MERCADO(cli_rec.id, v_segmercado_id);
    END LOOP;

    COMMIT;

END;

#TRABALHANDO COM EXCEPTION
create or replace PROCEDURE INCLUIR_CLIENTE 
   (p_id in cliente.id%type,
    p_razao_social IN cliente.razao_social%type,
    p_CNPJ cliente.CNPJ%type ,
    p_segmercado_id IN cliente.segmercado_id%type,
    p_faturamento_previsto IN cliente.faturamento_previsto%type)
IS
    v_categoria cliente.categoria%type;
    v_CNPJ cliente.cnpj%type := p_CNPJ;

BEGIN

    v_categoria := categoria_cliente(p_faturamento_previsto);
    
    FORMAT_CNPJ(v_CNPJ);

    INSERT INTO cliente VALUES (p_id, UPPER(p_razao_social), v_CNPJ,p_segmercado_id, SYSDATE, p_faturamento_previsto, v_categoria);
    COMMIT;

EXCEPTION
    WHEN dup_val_on_index then
        dbms_output.put_line ('Cliente já cadastrado');
END;

#TRATANDO EXCEÇÃO RAISE
CREATE OR REPLACE PROCEDURE INCLUIR_CLIENTE 
   (p_id in cliente.id%type,
    p_razao_social IN cliente.razao_social%type,
    p_CNPJ cliente.CNPJ%type ,
    p_segmercado_id IN cliente.segmercado_id%type,
    p_faturamento_previsto IN cliente.faturamento_previsto%type)
IS
    v_categoria cliente.categoria%type;
    v_CNPJ cliente.cnpj%type := p_CNPJ;
    e_null exception;
    pragma exception_init (e_null, -1400);

BEGIN

    v_categoria := categoria_cliente(p_faturamento_previsto);

    format_cnpj(v_cnpj);

    INSERT INTO cliente VALUES (p_id, UPPER(p_razao_social), v_CNPJ ,p_segmercado_id, SYSDATE, p_faturamento_previsto, v_categoria);
    COMMIT;

EXCEPTION
    WHEN dup_val_on_index then
        raise_application_error(-20010,'Cliente já cadastrado');
    WHEN e_null then
        raise_application_error(-20015,'A coluna ID tem preenchimento obrigatório');
    WHEN others then
        raise_application_error(-20020,sqlerrm());
END;

#SE SQL NÃO TRAZER NADA
CREATE OR REPLACE PROCEDURE ATUALIZAR_CLI_SEG_MERCADO
    (p_id IN cliente.id%type,
     p_segmercado_id IN cliente.segmercado_id%type)
IS
    e_cliente_id_inexistente exception;
BEGIN
    UPDATE cliente
        SET segmercado_id = p_segmercado_id
        WHERE id = p_id;
    IF SQL%NOTFOUND then
        RAISE e_cliente_id_inexistente;
    END IF;
    COMMIT;
EXCEPTION
    WHEN e_cliente_id_inexistente then
        raise_application_error(-20100,'Cliente inexistente');
END;

#CRIAR USUÁRIO E DAR PERMISSÃO

CREATE USER user_dev IDENTIFIED BY user_dev
DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP;

GRANT connect, resource TO user_dev;
GRANT create public synonym TO user_dev;
GRANT create view TO user_dev;
GRANT EXECUTE ANY PROCEDURE TO user_dev;
GRANT CREATE ANY DIRECTORY TO user_dev;

CREATE USER user_app IDENTIFIED BY user_app
DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP;

GRANT connect, resource TO user_app;

#CRIAR TABELAS, CHAVES PRIMÁRIAS E ESTRANGEIRAS

CREATE TABLE segmercado (id NUMBER(5),  			  
          descricao VARCHAR2(100));

ALTER TABLE Segmercado ADD CONSTRAINT 		
    segmercado_id_pk PRIMARY KEY(ID);

CREATE TABLE cliente
    ( ID NUMBER(5),
      razao_social VARCHAR2(100),
      CNPJ VARCHAR2(20),
      segmercado_id NUMBER(5),
      data_inclusao DATE,
      faturamento_previsto NUMBER(10,2),
      categoria VARCHAR2(20));

ALTER TABLE cliente ADD CONSTRAINT cliente_id_pk 
	PRIMARY KEY(ID);

ALTER TABLE cliente 
    ADD CONSTRAINT cliente_segmercado_fk 
    FOREIGN KEY(segmercado_id) 
    REFERENCES segmercado(id);
    
    
    
#POPULANDO AS TABELAS

BEGIN

   -- Incluir segmentos de mercado
   insert into segmercado values (1,'VAREJISTA');
   insert into segmercado values (2,'ATACADISTA');
   insert into segmercado values (3,'FARMACEUTICO');
   insert into segmercado values (4,'INDUSTRIAL');
   insert into segmercado values (5,'AGROPECUARIA');
   
   
   -- incluir clientes
   insert into cliente values (1 ,'SUPERMERCADO XYZ','12/345',5,sysdate,150000, 'GRANDE' );
   insert into cliente values (2 ,'SUPERMERCADO IJK','67/890',1,sysdate,90000, 'MEDIO GRANDE' );
   insert into cliente values (3 ,'SUPERMERCADO IJK','89/012',3,sysdate,80000, 'MEDIO GRANDE' );
   insert into cliente values (4 ,'FARMACIA AXZ','12/378',3, sysdate,80000,  'MEDIO GRANDE' );

   COMMIT;

END;
/

#CRIAÇÃO DE FUNÇÕES E PROCEDURES

-- No Oracle SQL Developer ir para: Menu Superior -> Ferramentas -> Preferencias
-- Banco de Dados -> Planilha 
-- Em SELECIONAR CAMINHO PADRÃO PARA PROCURA DE SCRIPTS colocar o local do script do curso. 

CREATE OR REPLACE FUNCTION OBTER_CATEGORIA_CLIENTE
    (p_faturamento_previsto IN cliente.faturamento_previsto%type)
    RETURN cliente.categoria%type
IS
BEGIN
    IF p_faturamento_previsto <= 10000 THEN 
       RETURN 'PEQUENO';
    ELSIF p_faturamento_previsto <= 50000 THEN
       RETURN 'MEDIO';
    ELSIF p_faturamento_previsto <= 100000  THEN
       RETURN 'MEDIO GRANDE';
    ELSE
       RETURN 'GRANDE';
    END IF;   
END;
/

CREATE OR REPLACE FUNCTION OBTER_DESCRICAO_SEGMENTO 
    (p_id in segmercado.id%type)
    RETURN segmercado.descricao%type
IS
    v_descricao segmercado.descricao%type;
BEGIN
    SELECT descricao INTO v_descricao
       FROM segmercado
       WHERE id = p_id;
    RETURN v_descricao;
EXCEPTION
        WHEN no_data_found then
            raise_application_error(-20002,'Segmento de Mercado	Inexistente');
END;
/

CREATE OR REPLACE FUNCTION VERIFICA_SEGMENTO_MERCADO
    (p_id in segmercado.id%type)
        RETURN boolean
IS
    v_dummy number(1);
BEGIN
    SELECT 1 into v_dummy
        FROM segmercado
        WHERE id = p_id;
    RETURN true;
EXCEPTION   
    WHEN no_data_found then
        RETURN false;
END;
/


CREATE OR REPLACE PROCEDURE FORMAT_CNPJ 
			(p_cnpj IN OUT varchar2)
IS
BEGIN
	p_cnpj := substr(p_cnpj,1,2) ||'/'|| substr(p_cnpj,3);
END;
/

CREATE OR REPLACE PROCEDURE ATUALIZAR_CLI_SEG_MERCADO
    (p_id cliente.id%type,
     p_segmercado_id cliente.segmercado_id%type)
IS
        e_fk exception;
        pragma exception_init(e_fk, -2291);
        e_no_update exception;
BEGIN
    UPDATE cliente
        SET segmercado_id = p_segmercado_id
        WHERE id = p_id;
    IF SQL%NOTFOUND then
        RAISE e_no_update;
    END IF;
    COMMIT;
EXCEPTION
    WHEN e_fk then
        RAISE_APPLICATION_ERROR (-20001,'Segmento de Mercado Inexistente');
    WHEN e_no_update then
       RAISE_APPLICATION_ERROR (-20002,'Cliente Inexistente');
END;
/

CREATE OR REPLACE PROCEDURE ATUALIZAR_FATURAMENTO_PREVISTO
    (p_id in cliente.id%type,
     p_faturamento_previsto in cliente.faturamento_previsto%type)
IS 
    v_categoria cliente.categoria%type;
    e_error_id exception;
BEGIN
    v_categoria := obter_categoria_cliente(p_faturamento_previsto);
    UPDATE cliente
        SET categoria = v_categoria,
            faturamento_previsto = p_faturamento_previsto
        WHERE id = p_id;
    IF SQL%NOTFOUND THEN
        RAISE e_error_id;
    END IF;
    COMMIT;
EXCEPTION
    WHEN e_error_id then
        raise_application_error(-20010,'Cliente inexistente');
END;
/

CREATE OR REPLACE PROCEDURE EXCLUIR_CLIENTE
    (p_id in cliente.id%type)
IS 
    e_error_id exception;
BEGIN
    DELETE FROM cliente
        WHERE id = p_id;
    IF SQL%NOTFOUND THEN
        RAISE e_error_id;
    END IF;
    COMMIT;
EXCEPTION
    WHEN e_error_id then
        raise_application_error(-20010,'Cliente inexistente');
END;
/

CREATE OR REPLACE PROCEDURE INCLUIR_CLIENTE 
   (p_id in cliente.id%type,
    p_razao_social in cliente.razao_social%type,
    p_CNPJ cliente.CNPJ%type ,
    p_segmercado_id cliente.segmercado_id%type,
    p_faturamento_previsto cliente.faturamento_previsto%type)
IS
    v_categoria cliente.categoria%type;
    v_CNPJ cliente.cnpj%type := p_CNPJ;
    v_codigo_erro number(5);
    v_mensagem_erro varchar2(200);
    v_dummy number;
    v_verifica_segmento boolean;
    e_segmento exception;
BEGIN
    v_verifica_segmento := 	verifica_segmento_mercado(p_segmercado_id);
    IF v_verifica_segmento = false THEN
        RAISE e_segmento;
    END IF;
    v_categoria := obter_categoria_cliente(p_faturamento_previsto);
    format_cnpj (v_cnpj);
    INSERT INTO cliente 
          VALUES (p_id, UPPER(p_razao_social), v_CNPJ, p_segmercado_id
                  ,SYSDATE, p_faturamento_previsto, v_categoria);
   COMMIT;   
EXCEPTION
    WHEN dup_val_on_index then
        raise_application_error(-20010,'Cliente já cadastrado');
    WHEN e_segmento then
        raise_application_error (-20011,'Segmento de mercado inexistente');
    WHEN OTHERS then
        v_codigo_erro := sqlcode;
        v_mensagem_erro := sqlerrm;
        raise_application_error (-20000,to_char(v_codigo_erro)||v_mensagem_erro);
END;
/

CREATE OR REPLACE PROCEDURE INCLUIR_SEGMERCADO
    (p_id in segmercado.id%type,
     p_descricao in segmercado.descricao%type)
IS
 BEGIN
    INSERT into segmercado 
       values(p_id, UPPER(p_descricao));
    COMMIT;
EXCEPTION
    WHEN dup_val_on_index THEN
        raise_application_error(-20001,'Segmento de Mercado já Cadastrado');
END;
/



CREATE OR REPLACE FUNCTION VERIFICA_SEGMENTO_MERCADO
    (p_id in segmercado.id%type)
        RETURN boolean
IS
    v_dummy number(1);
BEGIN
    SELECT 1 into v_dummy
        FROM segmercado
        WHERE id = p_id;
    RETURN true;
EXCEPTION   
    WHEN no_data_found then
        RETURN false;
END;
/


#RODAR SCRIPT

1- No menu superior, acesse Ferramentas -> Preferências... e selecione Banco de Dados -> Planilha. Em Selecionar caminho padrão para procurar scripts, clique em Procurar, selecione a pasta CursoAluraPacotesPLSQL, extraída anteriormente, e clique em OK.

#EXECUTAR SCRIPT

@ 01_Criar_Usuarios

#PERMISSÃO PARA O USUÁRIO EXECUTAR PROCEDURES

GRANT EXECUTE ON ATUALIZAR_CLI_SEG_MERCADO TO user_app;
GRANT EXECUTE ON ATUALIZAR_FATURAMENTO_PREVISTO TO user_app;
GRANT EXECUTE ON EXCLUIR_CLIENTE TO user_app;
GRANT EXECUTE ON INCLUIR_CLIENTE TO user_app;

#PERMISSÃO PARA O USUÁRIO EXECUTAR SELECT

GRANT SELECT ON CLIENTE TO user_app;

#CRIANDO SINONIMOS
CREATE PUBLIC SYNONYM INCLUIR_CLIENTE FOR user_dev.INCLUIR_CLIENTE;
CREATE PUBLIC SYNONYM ATUALIZAR_CLI_SEG_MERCADO FOR user_dev.ATUALIZAR_CLI_SEG_MERCADO;
CREATE PUBLIC SYNONYM ATUALIZAR_FATURAMENTO_PREVISTO FOR user_dev.ATUALIZAR_FATURAMENTO_PREVISTO;
CREATE PUBLIC SYNONYM EXCLUIR_CLIENTE FOR user_dev.EXCLUIR_CLIENTE;
CREATE PUBLIC SYNONYM CLIENTE FOR user_dev.CLIENTE;

#PROCEDURE CHAMANDO OUTRA COM SINONIMO
CREATE OR REPLACE PROCEDURE APL_INCLUIR_CLIENTE
   (p_id in cliente.id%type,
    p_razao_social in cliente.razao_social%type,
    p_CNPJ in cliente.CNPJ%type,
    p_segmercado_id in cliente.segmercado_id%type,
    p_faturamento_previsto in cliente.faturamento_previsto%type)
IS
BEGIN
    incluir_cliente(p_id ,p_razao_social,p_cnpj,p_segmercado_id,p_faturamento_previsto);
END;

#EXECUTANDO PROCEDURE
EXEC apl_incluir_cliente(6 ,'SEGUNDO CLIENTE INCLUIDO POR USER_APP','23456',2,100000);

#SCRIPT PARA CRIAR TABELA DE GERENCIAMENTO DE DEPENDÊNCIAS
Rem 
Rem $Header: utldtree.sql,v 1.2 1992/10/26 16:24:44 RKOOI Stab $ 
Rem 
Rem  Copyright (c) 1991 by Oracle Corporation 
Rem    NAME
Rem      deptree.sql - Show objects recursively dependent on given object
Rem    DESCRIPTION
Rem      This procedure, view and temp table will allow you to see all
Rem      objects that are (recursively) dependent on the given object.
Rem      Note: you will only see objects for which you have permission.
Rem      Examples:
Rem        execute deptree_fill('procedure', 'scott', 'billing');
Rem        select * from deptree order by seq#;
Rem
Rem        execute deptree_fill('table', 'scott', 'emp');
Rem        select * from deptree order by seq#;
Rem
Rem        execute deptree_fill('package body', 'scott', 'accts_payable');
Rem        select * from deptree order by seq#;
Rem
Rem        A prettier way to display this information than
Rem		select * from deptree order by seq#;
Rem	   is
Rem             select * from ideptree;
Rem        This shows the dependency relationship via indenting.  Notice
Rem        that no order by clause is needed with ideptree.
Rem    RETURNS
Rem 
Rem    NOTES
Rem      Run this script once for each schema that needs this utility.
Rem      
Rem    MODIFIED   (MM/DD/YY)
Rem     rkooi      10/26/92 -  owner -> schema for SQL2 
Rem     glumpkin   10/20/92 -  Renamed from DEPTREE.SQL 
Rem     rkooi      09/02/92 -  change ORU errors 
Rem     rkooi      06/10/92 -  add rae errors 
Rem     rkooi      01/13/92 -  update for sys vs. regular user 
Rem     rkooi      01/10/92 -  fix ideptree 
Rem     rkooi      01/10/92 -  Better formatting, add ideptree view 
Rem     rkooi      12/02/91 -  deal with cursors 
Rem     rkooi      10/19/91 -  Creation 

drop sequence deptree_seq
/
create sequence deptree_seq cache 200 /* cache 200 to make sequence faster */
/
drop table deptree_temptab
/
create table deptree_temptab
(
  object_id            number,
  referenced_object_id number,
  nest_level           number,
  seq#                 number      
)
/
create or replace procedure deptree_fill (type char, schema char, name char) is
  obj_id number;
begin
  delete from deptree_temptab;
  commit;
  select object_id into obj_id from all_objects
    where owner        = upper(deptree_fill.schema)
    and   object_name  = upper(deptree_fill.name)
    and   object_type  = upper(deptree_fill.type);
  insert into deptree_temptab
    values(obj_id, 0, 0, 0);
  insert into deptree_temptab
    select object_id, referenced_object_id,
        level, deptree_seq.nextval
      from public_dependency
      connect by prior object_id = referenced_object_id
      start with referenced_object_id = deptree_fill.obj_id;
exception
  when no_data_found then
    raise_application_error(-20000, 'ORU-10013: ' ||
      type || ' ' || schema || '.' || name || ' was not found.');
end;
/

drop view deptree
/

set echo on

REM This view will succeed if current user is sys.  This view shows 
REM which shared cursors depend on the given object.  If the current
REM user is not sys, then this view get an error either about lack
REM of privileges or about the non-existence of table x$kglxs.

set echo off
create view sys.deptree
  (nested_level, type, schema, name, seq#)
as
  select d.nest_level, o.object_type, o.owner, o.object_name, d.seq#
  from deptree_temptab d, dba_objects o
  where d.object_id = o.object_id (+)
union all
  select d.nest_level+1, 'CURSOR', '<shared>', '"'||c.kglnaobj||'"', d.seq#+.5
  from deptree_temptab d, x$kgldp k, x$kglob g, obj$ o, user$ u, x$kglob c,
      x$kglxs a
    where d.object_id = o.obj#
    and   o.name = g.kglnaobj
    and   o.owner# = u.user#
    and   u.name = g.kglnaown
    and   g.kglhdadr = k.kglrfhdl
    and   k.kglhdadr = a.kglhdadr   /* make sure it is not a transitive */
    and   k.kgldepno = a.kglxsdep   /* reference, but a direct one */
    and   k.kglhdadr = c.kglhdadr
    and   c.kglhdnsp = 0 /* a cursor */
/

set echo on

REM This view will succeed if current user is not sys.  This view
REM does *not* show which shared cursors depend on the given object.
REM If the current user is sys then this view will get an error 
REM indicating that the view already exists (since prior view create
REM will have succeeded).

set echo off
create view deptree
  (nested_level, type, schema, name, seq#)
as
  select d.nest_level, o.object_type, o.owner, o.object_name, d.seq#
  from deptree_temptab d, all_objects o
  where d.object_id = o.object_id (+)
/

drop view ideptree
/
create view ideptree (dependencies)
as
  select lpad(' ',3*(max(nested_level))) || max(nvl(type, '<no permission>')
    || ' ' || schema || decode(type, NULL, '', '.') || name)
  from deptree
  group by seq# /* So user can omit sort-by when selecting from ideptree */
/

#CRIAR GERENCIAMENTO DE DEPENDENCIA PARA UM DETERMINADO OBJETO
EXEC DEPTREE_FILL('table','user_dev','cliente')

#VISUALIZAR AS DEPENDÊNCIAS DO OBJETO CRIADO ANTERIORMENTE
SELECT NESTED_LEVEL,SCHEMA,TYPE,NAME FROM DEPTREE
ORDER BY SEQ#

#CRIANDO PACOTE (CABEÇALHO)
CREATE OR REPLACE PACKAGE CLIENTE_PAC IS

    PROCEDURE ATUALIZAR_CLI_SEG_MERCADO
    (p_id in cliente.id%type,
     p_segmercado_id in cliente.segmercado_id%type);

    PROCEDURE ATUALIZAR_FATURAMENTO_PREVISTO
    (p_id in cliente.id%type,
     p_faturamento_previsto in cliente.faturamento_previsto%type);

    PROCEDURE EXCLUIR_CLIENTE
    (p_id in cliente.id%type);

    PROCEDURE INCLUIR_CLIENTE 
    (p_id in cliente.id%type,
     p_razao_social in cliente.razao_social%type,
     p_CNPJ in cliente.CNPJ%type ,
     p_segmercado_id in cliente.segmercado_id%type,
     p_faturamento_previsto in cliente.faturamento_previsto%type);

END;

#CRIANDO PACOTE (CORPO)
CREATE OR REPLACE PACKAGE BODY cliente_pac IS

    PROCEDURE atualizar_cli_seg_mercado (
        p_id              IN cliente.id%TYPE,
        p_segmercado_id   IN cliente.segmercado_id%TYPE
    ) IS
        e_fk EXCEPTION;
        PRAGMA exception_init ( e_fk,-2291 );
        e_no_update EXCEPTION;
    BEGIN
        UPDATE cliente
            SET
                segmercado_id = p_segmercado_id
        WHERE
            id = p_id;

        IF
            SQL%notfound
        THEN
            RAISE e_no_update;
        END IF;
        COMMIT;
    EXCEPTION
        WHEN e_fk THEN
            raise_application_error(-20001,'Segmento de Mercado Inexistente');
        WHEN e_no_update THEN
            raise_application_error(-20002,'Cliente Inexistente');
    END;

    PROCEDURE atualizar_faturamento_previsto (
        p_id                     IN cliente.id%TYPE,
        p_faturamento_previsto   IN cliente.faturamento_previsto%TYPE
    ) IS
        v_categoria   cliente.categoria%TYPE;
        e_error_id EXCEPTION;
    BEGIN
        v_categoria := obter_categoria_cliente(p_faturamento_previsto);
        UPDATE cliente
            SET
                categoria = v_categoria,
                faturamento_previsto = p_faturamento_previsto
        WHERE
            id = p_id;

        IF
            SQL%notfound
        THEN
            RAISE e_error_id;
        END IF;
        COMMIT;
    EXCEPTION
        WHEN e_error_id THEN
            raise_application_error(-20010,'Cliente inexistente');
    END;

    PROCEDURE excluir_cliente (
        p_id   IN cliente.id%TYPE
    ) IS
        e_error_id EXCEPTION;
    BEGIN
        DELETE FROM cliente WHERE
            id = p_id;

        IF
            SQL%notfound
        THEN
            RAISE e_error_id;
        END IF;
        COMMIT;
    EXCEPTION
        WHEN e_error_id THEN
            raise_application_error(-20010,'Cliente inexistente');
    END;

    PROCEDURE incluir_cliente (
        p_id                     IN cliente.id%TYPE,
        p_razao_social           IN cliente.razao_social%TYPE,
        p_cnpj                   IN cliente.cnpj%TYPE,
        p_segmercado_id          IN cliente.segmercado_id%TYPE,
        p_faturamento_previsto   IN cliente.faturamento_previsto%TYPE
    ) IS
        v_categoria           cliente.categoria%TYPE;
        v_cnpj                cliente.cnpj%TYPE := p_cnpj;
        v_codigo_erro         NUMBER(5);
        v_mensagem_erro       VARCHAR2(200);
        v_dummy               NUMBER;
        v_verifica_segmento   BOOLEAN;
        e_segmento EXCEPTION;
    BEGIN
        v_verifica_segmento := verifica_segmento_mercado(p_segmercado_id);
        IF
            v_verifica_segmento = false
        THEN
            RAISE e_segmento;
        END IF;
        v_categoria := obter_categoria_cliente(p_faturamento_previsto);
        format_cnpj(v_cnpj);
        INSERT INTO cliente VALUES (
            p_id,
            upper(p_razao_social),
            v_cnpj,
            p_segmercado_id,
            SYSDATE,
            p_faturamento_previsto,
            v_categoria
        );

        COMMIT;
    EXCEPTION
        WHEN dup_val_on_index THEN
            raise_application_error(-20010,'Cliente já cadastrado');
        WHEN e_segmento THEN
            raise_application_error(-20011,'Segmento de mercado inexistente');
        WHEN OTHERS THEN
            v_codigo_erro := sqlcode;
            v_mensagem_erro := sqlerrm;
            raise_application_error(-20000,TO_CHAR(v_codigo_erro)
            || v_mensagem_erro);
    END;

END;

#DANDO PERMISSÃO PARA O PACOTE
GRANT EXECUTE ON CLIENTE_PAC TO user_app;

#EXECUTANDO O PACOTE
EXEC user_dev.cliente_pac.incluir_cliente(10 ,'INCLUIDO POR USER_APP VIA PACKAGE','24890',2,100000);

#CRIANDO SINONIMO PARA O PACOTE
CREATE PUBLIC SYNONYM CLIENTE_PAC FOR user_dev.CLIENTE_PAC;

#EXECUTANDO O PACOTE COM SINONIMO
EXEC cliente_pac.incluir_cliente(11 ,'SEGUNDO INCLUIDO POR USER_APP VIA PACKAGE','24890',2,100000);
EXEC cliente_pac.excluir_cliente(10)